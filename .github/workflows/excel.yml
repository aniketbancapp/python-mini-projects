name: SonarQube Scan with Enhanced Report

on:
  push:
    branches: [ master ]
  pull_request:
    types: [opened, synchronize, reopened]

env:
  SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
  SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

jobs:
  sonarqube-scan:
    name: SonarQube Scan with Enhanced Report
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '17'

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl pandoc

      - name: Run SonarQube Scan
        uses: sonarsource/sonarqube-scan-action@master
        with:
          args: >
            -Dsonar.projectKey=python
            -Dsonar.projectName="Python Project"
            -Dsonar.projectVersion=1.0
            -Dsonar.sources=.
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.host.url=${{ env.SONAR_HOST_URL }}
            -Dsonar.login=${{ env.SONAR_TOKEN }}
            -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info

      - name: Verify analysis completion
        run: |
          echo "Checking analysis status..."
          CE_TASK_ID=$(grep "ceTaskId=" .scannerwork/report-task.txt | cut -d'=' -f2)
          echo "Task ID: $CE_TASK_ID"

          for i in {1..30}; do
            API_RESPONSE=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_HOST_URL/api/ce/task?id=$CE_TASK_ID")
            echo "API Response: $API_RESPONSE"
            
            TASK_STATUS=$(echo "$API_RESPONSE" | jq -r '.task.status')
            echo "Attempt $i: Status - $TASK_STATUS"
            
            if [ "$TASK_STATUS" = "SUCCESS" ]; then
              break
            elif [ "$TASK_STATUS" = "FAILED" ] || [ "$TASK_STATUS" = "CANCELED" ]; then
              echo "Analysis failed or was canceled"
              exit 1
            elif [ $i -eq 30 ]; then
              echo "Timeout waiting for analysis completion"
              exit 1
            fi
            sleep 5
          done

      - name: Wait for metrics calculation
        run: sleep 30

      - name: Generate Enhanced SonarQube Report
        run: |
          # Get project information
          PROJECT_KEY=$(grep "projectKey=" .scannerwork/report-task.txt | cut -d'=' -f2)
          DASHBOARD_URL=$(grep "dashboardUrl=" .scannerwork/report-task.txt | cut -d'=' -f2)
          CURRENT_DATE=$(date +"%d-%m-%Y")
          COMMIT_ID=${GITHUB_SHA:0:7}

          # Function to make authenticated API calls with error handling
          sonar_api_call() {
            local endpoint="$1"
            local response=$(curl -s -u "$SONAR_TOKEN:" "$SONAR_HOST_URL/api/$endpoint")
            echo "$response" | jq -e . >/dev/null 2>&1
            if [ $? -ne 0 ]; then
              echo "Error: Invalid JSON response from API endpoint $endpoint"
              echo "Response: $response"
              exit 1
            fi
            echo "$response"
          }

          # Get measures data with fallback values
          echo "Fetching measures data..."
          MEASURES=$(sonar_api_call "measures/component?component=$PROJECT_KEY&metricKeys=bugs,vulnerabilities,code_smells,security_hotspots,duplicated_lines_density,coverage,ncloc,reliability_rating,security_rating,sqale_rating,security_review_rating")
          echo "Measures data: $MEASURES"

          # Get issues data
          echo "Fetching issues data..."
          ISSUES=$(sonar_api_call "issues/search?componentKeys=$PROJECT_KEY&resolved=false&ps=500")
          echo "Issues data: $ISSUES"

          # Get hotspots data
          echo "Fetching hotspots data..."
          HOTSPOTS=$(sonar_api_call "hotspots/search?projectKey=$PROJECT_KEY&status=TO_REVIEW")
          echo "Hotspots data: $HOTSPOTS"

          # Safe metric extraction with defaults
          extract_metric() {
            local json="$1"
            local metric="$2"
            local default="${3:-0}"
            
            local value=$(echo "$json" | jq -r --arg metric "$metric" '.component.measures[]? | select(.metric == $metric) | .value? // empty')
            if [ -z "$value" ]; then
              echo "$default"
            else
              echo "$value"
            fi
          }

          # Basic metrics with defaults
          BUGS=$(extract_metric "$MEASURES" "bugs")
          VULNERABILITIES=$(extract_metric "$MEASURES" "vulnerabilities")
          CODE_SMELLS=$(extract_metric "$MEASURES" "code_smells")
          SECURITY_HOTSPOTS=$(extract_metric "$MEASURES" "security_hotspots")
          DUPLICATION=$(extract_metric "$MEASURES" "duplicated_lines_density")
          COVERAGE=$(extract_metric "$MEASURES" "coverage")
          NCLOC=$(extract_metric "$MEASURES" "ncloc")

          # Ratings with defaults
          RELIABILITY_RATING=$(extract_metric "$MEASURES" "reliability_rating" "1.0")
          SECURITY_RATING=$(extract_metric "$MEASURES" "security_rating" "1.0")
          MAINTAINABILITY_RATING=$(extract_metric "$MEASURES" "sqale_rating" "1.0")
          SECURITY_REVIEW_RATING=$(extract_metric "$MEASURES" "security_review_rating" "1.0")

          # Convert ratings to letter grades
          convert_rating() {
            case $1 in
              "1.0") echo "A";;
              "2.0") echo "B";;
              "3.0") echo "C";;
              "4.0") echo "D";;
              "5.0") echo "E";;
              *) echo "A";;
            esac
          }

          BUG_GRADE=$(convert_rating "$RELIABILITY_RATING")
          VULN_GRADE=$(convert_rating "$SECURITY_RATING")
          CODE_GRADE=$(convert_rating "$MAINTAINABILITY_RATING")
          HOTSPOT_GRADE=$(convert_rating "$SECURITY_REVIEW_RATING")

          # Issues by severity with safe defaults
          BLOCKER=$(echo "$ISSUES" | jq -r '[.issues[]? | select(.severity == "BLOCKER")] | length // 0')
          CRITICAL=$(echo "$ISSUES" | jq -r '[.issues[]? | select(.severity == "CRITICAL")] | length // 0')
          MAJOR=$(echo "$ISSUES" | jq -r '[.issues[]? | select(.severity == "MAJOR")] | length // 0')
          MINOR=$(echo "$ISSUES" | jq -r '[.issues[]? | select(.severity == "MINOR")] | length // 0')
          INFO=$(echo "$ISSUES" | jq -r '[.issues[]? | select(.severity == "INFO")] | length // 0')
          TOTAL_ISSUES=$((BLOCKER + CRITICAL + MAJOR + MINOR + INFO))

          # Security hotspots by risk with safe defaults
          HOTSPOT_LOW=$(echo "$HOTSPOTS" | jq -r '[.hotspots[]? | select(.vulnerabilityProbability == "LOW")] | length // 0')
          HOTSPOT_MEDIUM=$(echo "$HOTSPOTS" | jq -r '[.hotspots[]? | select(.vulnerabilityProbability == "MEDIUM")] | length // 0')
          HOTSPOT_HIGH=$(echo "$HOTSPOTS" | jq -r '[.hotspots[]? | select(.vulnerabilityProbability == "HIGH")] | length // 0')
          TOTAL_HOTSPOTS=$((HOTSPOT_LOW + HOTSPOT_MEDIUM + HOTSPOT_HIGH))

          # Create markdown report
          cat <<EOF > sonar-report.md
# SonarQube Analysis Report

## Project Information
- **Project Name**: Python Project
- **Project Key**: $PROJECT_KEY
- **Analysis Date**: $CURRENT_DATE
- **Commit ID**: $COMMIT_ID
- **Report URL**: [$DASHBOARD_URL]($DASHBOARD_URL)

## Quality Gate Summary
| Metric               | Value       |
|----------------------|-------------|
| Bugs                 | $BUGS ($BUG_GRADE) |
| Vulnerabilities      | $VULNERABILITIES ($VULN_GRADE) |
| Code Smells          | $CODE_SMELLS ($CODE_GRADE) |
| Security Hotspots    | $SECURITY_HOTSPOTS ($HOTSPOT_GRADE) |
| Duplicated Code (%)  | $DUPLICATION |
| Coverage (%)         | $COVERAGE |
| Lines of Code        | $NCLOC |

## Issues Breakdown
| Severity  | Count  |
|-----------|--------|
| Blocker   | $BLOCKER |
| Critical  | $CRITICAL |
| Major     | $MAJOR |
| Minor     | $MINOR |
| Info      | $INFO |
| **Total** | **$TOTAL_ISSUES** |

## Security Hotspots
| Risk Level | Count  |
|------------|--------|
| High       | $HOTSPOT_HIGH |
| Medium     | $HOTSPOT_MEDIUM |
| Low        | $HOTSPOT_LOW |
| **Total**  | **$TOTAL_HOTSPOTS** |

## Recommendations
- Address all Blocker and Critical issues immediately
- Review all Security Hotspots, especially High risk ones
- Improve test coverage to at least 80%
- Reduce code duplication below 5%
EOF

          # Convert markdown to HTML
          pandoc sonar-report.md -o sonar-report.html

          # Debug output
          echo "Generated report content:"
          cat sonar-report.md

      - name: Upload HTML Report
        uses: actions/upload-artifact@v4
        with:
          name: sonarqube-report
          path: sonar-report.html

      - name: Upload Markdown Report
        uses: actions/upload-artifact@v4
        with:
          name: sonarqube-report-md
          path: sonar-report.md
